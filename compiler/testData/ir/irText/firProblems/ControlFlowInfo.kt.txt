interface ImmutableCollection<out E : Any?> : Collection<E> {

}

interface ImmutableSet<out E : Any?> : Set<E>, ImmutableCollection<E> {

}

interface ImmutableMap<K : Any?, out V : Any?> : Map<K, V> {
  abstract override val keys: ImmutableSet<K>
    abstract override get

  abstract override val values: ImmutableCollection<V>
    abstract override get

  abstract override val entries: ImmutableSet<Entry<K, V>>
    abstract override get

}

interface PersistentMap<K : Any?, out V : Any?> : ImmutableMap<K, V> {
  abstract fun put(key: K, value: @UnsafeVariance V): PersistentMap<K, V>
  abstract fun remove(key: K): PersistentMap<K, V>
  abstract fun remove(key: K, value: @UnsafeVariance V): PersistentMap<K, V>
  abstract fun putAll(m: Map<out K, @UnsafeVariance V>): PersistentMap<K, V>
  abstract fun clear(): PersistentMap<K, V>

}

abstract class ControlFlowInfo<S : ControlFlowInfo<S, K, V>, K : Any, V : Any> : PersistentMap<K, V> {
  protected constructor(map: PersistentMap<K, V>) /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

  protected val map: PersistentMap<K, V>
    field = map
    protected get

  override val entries: ImmutableSet<Entry<K, V>>
    override get(): ImmutableSet<Entry<K, V>> {
      return <this>.#map.<get-entries>()
    }

  override val keys: ImmutableSet<K>
    override get(): ImmutableSet<K> {
      return <this>.#map.<get-keys>()
    }

  override val size: Int
    override get(): Int {
      return <this>.#map.<get-size>()
    }

  override val values: ImmutableCollection<V>
    override get(): ImmutableCollection<V> {
      return <this>.#map.<get-values>()
    }

  override fun clear(): PersistentMap<K, V> {
    return <this>.#map.clear()
  }

  override fun containsKey(key: K): Boolean {
    return <this>.#map.containsKey(key = key)
  }

  override fun containsValue(value: V): Boolean {
    return <this>.#map.containsValue(value = value)
  }

  override operator fun get(key: K): V? {
    return <this>.#map.get(key = key)
  }

  override fun isEmpty(): Boolean {
    return <this>.#map.isEmpty()
  }

  override fun putAll(m: Map<out K, V>): PersistentMap<K, V> {
    return <this>.#map.putAll(m = m)
  }

  override fun remove(key: K, value: V): PersistentMap<K, V> {
    return <this>.#map.remove(key = key, value = value)
  }

  protected abstract val constructor: Function1<PersistentMap<K, V>, S>
    protected abstract get

  protected abstract val empty: Function0<S>
    protected abstract get

  override operator fun equals(other: Any?): Boolean {
    return EQEQ(arg0 = <this>.<get-map>(), arg1 = { // BLOCK
      val tmp0_safe_receiver: ControlFlowInfo<*, *, *>? = other as? ControlFlowInfo<*, *, *>
      when {
        EQEQ(arg0 = tmp0_safe_receiver, arg1 = null) -> null
        else -> tmp0_safe_receiver.<get-map>()
      }
    })
  }

  override fun hashCode(): Int {
    return <this>.<get-map>().hashCode()
  }

  override fun toString(): String {
    return <this>.<get-map>().toString()
  }

  override fun put(key: K, value: V): S {
    return <this>.<get-constructor>().invoke(p1 = <this>.<get-map>().put(key = key, value = value))
  }

  override fun remove(key: K): S {
    return <this>.<get-constructor>().invoke(p1 = <this>.<get-map>().remove(key = key))
  }

  abstract fun merge(other: S): S

}

class EdgeLabel {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

abstract class PathAwareControlFlowInfo<P : PathAwareControlFlowInfo<P, S>, S : ControlFlowInfo<S, *, *>> : ControlFlowInfo<P, EdgeLabel, S> {
  constructor(map: PersistentMap<EdgeLabel, S>) /* primary */ {
    super/*ControlFlowInfo*/<P, EdgeLabel, S>(map = map)
    /* <init>() */

  }

  override fun merge(other: P): P {
    return other
  }

}

class EventOccurrencesRange {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

abstract class EventOccurrencesRangeInfo<E : EventOccurrencesRangeInfo<E, K>, K : Any> : ControlFlowInfo<E, K, EventOccurrencesRange> {
  constructor(map: PersistentMap<K, EventOccurrencesRange>) /* primary */ {
    super/*ControlFlowInfo*/<E, K, EventOccurrencesRange>(map = map)
    /* <init>() */

  }

}

abstract class PropertyInitializationInfo : EventOccurrencesRangeInfo<PropertyInitializationInfo, String> {
  constructor(map: PersistentMap<String, EventOccurrencesRange>) /* primary */ {
    super/*EventOccurrencesRangeInfo*/<PropertyInitializationInfo, String>(map = map)
    /* <init>() */

  }

}

class PathAwarePropertyInitializationInfo : PathAwareControlFlowInfo<PathAwarePropertyInitializationInfo, PropertyInitializationInfo> {
  constructor(map: PersistentMap<EdgeLabel, PropertyInitializationInfo>) /* primary */ {
    super/*PathAwareControlFlowInfo*/<PathAwarePropertyInitializationInfo, PropertyInitializationInfo>(map = map)
    /* <init>() */

  }

  companion object Companion {
    private constructor() /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    val EMPTY: PathAwarePropertyInitializationInfo
      field = PathAwarePropertyInitializationInfo(map = CHECK_NOT_NULL<Nothing>(arg0 = null))
      get

  }

  protected override val constructor: Function1<PersistentMap<EdgeLabel, PropertyInitializationInfo>, PathAwarePropertyInitializationInfo>
    field = PathAwarePropertyInitializationInfo::<init>
    protected override get

  protected override val empty: Function0<PathAwarePropertyInitializationInfo>
    field = Companion::EMPTY
    protected override get

}
